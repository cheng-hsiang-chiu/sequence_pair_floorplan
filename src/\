#include "sp.hpp"



namespace sp {
 
 
  
class SequencePairTester{
  public:

    SequencePair sp;

    SequencePairTester() = default;

    void open(const std::string input_file);

    void rotate_module();
    
    void generate_initial_pair();

    std::vector<Node> get_modules();

    void swap_two_nodes_one_sequence(std::vector<int>& sequence);

    /*
    double _calculate_initial_temperature();

    void _simulated_annealing(const double initial_temperature);

    void _generate_neighbors(std::vector<int>& positive_sequence_prop,
                             std::vector<int>& negative_sequence_prop);

    size_t _pack(const std::vector<int> positive_sequence,
                 const std::vector<int> negative_sequence);

    void _pack_helper(const std::vector<int> positive_sequence,
                      const std::vector<int> negative_sequence, 
                      const bool is_horizontal);



    void _swap_two_nodes_two_sequences(
      std::vector<int>& positive_sequence_prop,
      std::vector<int>& negative_sequence_prop);

    graph::DAG _generate_dag(
      const std::vector<int> positive_sequence,
      const std::vector<int> negative_sequence,
      const bool is_horizontal) const;
    */
};


// read in the module configurations
void SequencePairTester::open(const std::string input_file) {

  std::cout << "sp tester open\n";
  sp.open(input_file);
}


// generate an initial pair
void SequencePairTester::generate_initial_pair() {

  sp._generate_initial_pair();
}


// get the modules
std::vector<Node> SequencePairTester::get_modules() {
  
  return sp._modules;
}


// rotate a moudle
void SequencePairTester::rotate_module() {
 
  sp._rotate_module(); 
}


// swap two modules in one sequence
void SequencePairTester::swap_two_nodes_one_sequence(
  std::vector<int>& sequence) {
  
  std::uniform_real_distribution<> dis(0.0, _modules.size());

  size_t id1 = static_cast<size_t>(dis(_gen));
  size_t id2 = static_cast<size_t>(dis(_gen));

  while(id1 == id2) {
    id2 = static_cast<size_t>(dis(_gen));
  }

  std::swap(sequence[id1], sequence[id2]);
}





/*
// calculate initial temperature
double SequencePair::_calculate_initial_temperature() {
  
  size_t num_moves = 0;
  double total_area_change = 0.0;
  double delta_area, avg_area_change, init_temperature;
  
  std::vector<int> positive_sequence_curr = _positive_sequence;
  std::vector<int> negative_sequence_curr = _negative_sequence;
  std::vector<int> positive_sequence_prop = _positive_sequence;
  std::vector<int> negative_sequence_prop = _negative_sequence;

  size_t area_curr = _pack(positive_sequence_curr, negative_sequence_curr);
  size_t area_prop;

  while(num_moves < SP_RANDOM_MOVES) {
    _generate_neighbors(positive_sequence_prop, negative_sequence_prop);

    area_prop = _pack(positive_sequence_prop, negative_sequence_prop);
    delta_area = area_prop > area_curr ? 
                 (area_prop - area_curr) : 
                 (area_curr - area_prop); 

    total_area_change += delta_area;
    ++num_moves;
    positive_sequence_curr = positive_sequence_prop;
    negative_sequence_curr = negative_sequence_prop;
    area_curr = area_prop;
  }

  avg_area_change = total_area_change / num_moves;
  
  init_temperature = SP_P < 1 ? (SP_T0 * avg_area_change) / log(SP_P) : 
                                avg_area_change / log(SP_P);

  return init_temperature;
}


// perform simulated annealing
void SequencePair::_simulated_annealing(const double initial_temperature) {
 
  std::uniform_real_distribution<> dis(0.0, 1.0);
  
  double temperature = initial_temperature;

  std::vector<int> positive_sequence_prop;
  std::vector<int> negative_sequence_prop;
  std::vector<int> positive_sequence_curr;
  std::vector<int> negative_sequence_curr;
  std::vector<int> positive_sequence_best;
  std::vector<int> negative_sequence_best;
    
  positive_sequence_curr = _positive_sequence;
  negative_sequence_curr = _negative_sequence;

  positive_sequence_best = positive_sequence_curr;
  negative_sequence_best = negative_sequence_curr;
    
  size_t area_best = _pack(positive_sequence_best,
                           negative_sequence_best);
  size_t area_curr = area_best; 
   
  while(temperature > SP_FROZEN_TEMPERATURE) {
    for(size_t iter = 0; iter < SP_MAX_ITERATIONS_PER_TEMPERATURE; iter++) {
      positive_sequence_prop = positive_sequence_curr;
      negative_sequence_prop = negative_sequence_curr;

      _generate_neighbors(positive_sequence_prop, 
                         negative_sequence_prop);
      
      size_t area_prop = _pack(positive_sequence_prop,
                               negative_sequence_prop);

      double cost = area_prop < area_curr ?
                    (double)-1*(area_curr - area_prop) : 
                    (area_prop - area_curr);


      //std::cout << "postfix_prop : " << postfix_prop << '\n'; 
      //std::cout << "postfix_curr : " << postfix_curr << '\n'; 
      //std::cout << "postfix_best : " << postfix_best << '\n'; 
      //std::cout << "area_best : " << area_best << '\n';
      //std::cout << "area_curr : " << area_curr << '\n';
      //std::cout << "area_prop : " << area_prop << '\n';
      //std::cout << "@@@@@@@@@@@@@@@@@@@@@\n";

      if(cost < 0) {
        positive_sequence_curr = positive_sequence_prop;
        negative_sequence_curr = negative_sequence_prop;
  
        area_curr = area_prop;

        if(area_prop < area_best) {
          positive_sequence_best = positive_sequence_prop;
          negative_sequence_best = negative_sequence_prop;

          area_best = area_prop;
          _modules_best = _modules;
        }
        //_cost.push_back(abs(cost));
      }

      else {
        auto prob = std::exp(-cost / temperature); 
        if(prob > dis(_gen)) {
          positive_sequence_curr = positive_sequence_prop;
          negative_sequence_curr = negative_sequence_prop;
  
          area_curr = area_prop; 
          //_cost.push_back(cost);
        }
      }
    }
    temperature *= 0.95;  
  }

  _positive_sequence = positive_sequence_best;
  _negative_sequence = negative_sequence_best;
}


// generate neighbors
void SequencePair::_generate_neighbors(
  std::vector<int>& positive_sequence_prop,
  std::vector<int>& negative_sequence_prop) {

  std::uniform_real_distribution<> dis(0.0, 3.0);
  int choice = dis(_gen);

  switch(choice) {
    case 0:
      _rotate_module();
      break;
    case 1:
      if (dis(_gen)/3 > 0.5) {
        _swap_two_nodes_one_sequence(positive_sequence_prop);
      }
      else {
        _swap_two_nodes_one_sequence(negative_sequence_prop);
      }
      break;
    case 2:
    _swap_two_nodes_two_sequences(positive_sequence_prop,
                                  negative_sequence_prop); 
    break;
  }
}


// pack the modules
size_t SequencePair::_pack(const std::vector<int> positive_sequence,
                           const std::vector<int> negative_sequence) {
  
  _pack_helper(positive_sequence, negative_sequence, true);
  _pack_helper(positive_sequence, negative_sequence, false);
 
  //std::cout << "finished pack helper\n"; 
  size_t urx = 0, ury = 0;
  
  for (size_t i = 0; i < _modules.size(); ++i) {
    if (_modules[i].llx + _modules[i].width > urx) {
      urx = _modules[i].llx + _modules[i].width;
    }

    if (_modules[i].lly + _modules[i].height > ury) {
      ury = _modules[i].lly + _modules[i].height;
    }
  }

  _urx = urx;
  _ury = ury;

  return (_urx * _ury);  
}


// pack helper
void SequencePair::_pack_helper(const std::vector<int> positive_sequence, 
                                const std::vector<int> negative_sequence,
                                const bool is_horizontal) {

  if (is_horizontal) {
    _dag = _generate_dag(positive_sequence,
                         negative_sequence,
                         true);

    std::vector<int> topology_order = _dag.get_topology_order();
    std::vector<graph::Node> all_nodes = _dag.get_nodes();
    std::vector<int> longest_path = 
      _dag.longest_path(all_nodes[topology_order[0]]);
  
    for (size_t i = 0; i < longest_path.size(); ++i) {
      _modules[i].llx = longest_path[i];  
    }
  }

  else {
    _dag = _generate_dag(positive_sequence,
                         negative_sequence,
                         false);

    std::vector<int> topology_order = _dag.get_topology_order();
    std::vector<graph::Node> all_nodes = _dag.get_nodes();
    std::vector<int> longest_path = 
      _dag.longest_path(all_nodes[topology_order[0]]);
  
    for (size_t i = 0; i < longest_path.size(); ++i) {
      _modules[i].lly = longest_path[i];  
    }
  }
}






// swap two moduels in both sequences
void SequencePair::_swap_two_nodes_two_sequences(
  std::vector<int>& positive_sequence_prop,
  std::vector<int>& negative_sequence_prop) {
  
  std::uniform_real_distribution<> dis(0.0, _modules.size());

  size_t pid1 = static_cast<size_t>(dis(_gen));
  size_t pid2 = static_cast<size_t>(dis(_gen));

  while(pid1 == pid2) {
    pid2 = static_cast<size_t>(dis(_gen));
  }

  size_t nid1 = _modules.size();
  size_t nid2 = _modules.size();

  for (size_t i = 0; i < _modules.size(); ++i) {
    if (negative_sequence_prop[i] == positive_sequence_prop[pid1]) {
      nid1 = pid1;
    }

    if (negative_sequence_prop[i] == positive_sequence_prop[pid2]) {
      nid2 = pid2;
    }

    if ((nid1 != _modules.size()) && (nid2 != _modules.size())) {
      break;
    }
  }

  std::swap(positive_sequence_prop[pid1], positive_sequence_prop[pid2]);
  std::swap(negative_sequence_prop[nid1], negative_sequence_prop[nid2]);
}


// generate a DAG
graph::DAG SequencePair::_generate_dag(
  const std::vector<int> positive_sequence,
  const std::vector<int> negative_sequence,
  const bool is_horizontal) const {

  graph::DAG dag(positive_sequence.size());
  //graph::Node node1(0, 0);
  //graph::Node node2(0, 0);
   
  int pidx = 0, nidx = 0;

  while (pidx < positive_sequence.size()) {
    
    std::set<int> sequence;
    
    size_t node1_id = positive_sequence[pidx]; 
    size_t node1_cost;

    
    for (size_t i = 0; i < _modules.size(); ++i) {
      if (node1_id == _modules[i].id) {
        if (is_horizontal) {
          node1_cost = _modules[i].width; 
        }
        else {
          node1_cost = _modules[i].height;
        }
        break;
      }
    }
    
    graph::Node node1(node1_id, node1_cost);
    //std::cout << "node1 at " << &node1 << '\n';
    //node1.set_id(node1_id);
    //node1.set_cost(node1_cost);

    for (size_t i = pidx+1; i < positive_sequence.size(); i++) {
      sequence.insert(positive_sequence[i]);
    }

    for (size_t i = 0; i < negative_sequence.size(); ++i) {
      if (positive_sequence[pidx] == negative_sequence[i]) {
        nidx = i;
        break;
      }
    }

    if (is_horizontal) {
      for (size_t i = nidx+1; i < negative_sequence.size(); ++i) {
        
        size_t original_size = sequence.size();
        
        sequence.insert(negative_sequence[i]);
        
        if (original_size == sequence.size()) {
          size_t node2_id = negative_sequence[i]; 
          size_t node2_cost;

          for (size_t i = 0; i < _modules.size(); ++i) {
            if (node2_id == _modules[i].id) {
              node2_cost = _modules[i].width; 
              break;
            }
          }

          graph::Node node2(node2_id, node2_cost);
          //std::cout << "node2 at " << &node2 << '\n';
          dag.add_edge(node1, node2);
        }
      }
    }

    else {
      //std::cout << "vertical dag with nidx = " << nidx << " \n";

      for (int i = nidx-1; i >= 0; --i) {
        
        size_t original_size = sequence.size();
        
        sequence.insert(negative_sequence[i]);
        
        if (original_size == sequence.size()) {
          //std::cout << "nidx = " << nidx << " and i = " << i << '\n';
          size_t node2_id = negative_sequence[i]; 
          size_t node2_cost;

          for (size_t i = 0; i < _modules.size(); ++i) {
            if (node2_id == _modules[i].id) {
              node2_cost = _modules[i].height;
              break;
            }
          }

          graph::Node node2(node2_id, node2_cost);
          //std::cout << "node2 at " << &node2 << '\n';
          dag.add_edge(node1, node2);
        }
      }
    }
    ++pidx;
  }
  //dag.dump(std::cout);
  
  std::vector<graph::Node*> all_nodes = dag.get_nodes();
  for (size_t i = 0; i < all_nodes.size(); ++i)
    std::cout << all_nodes[i]->id << " has cost = " << all_nodes[i]->cost << '\n';
  
  return dag;



}
*/




}
